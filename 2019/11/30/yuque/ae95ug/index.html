<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC]  基础知识复习 宏  无参宏 有参宏 (带有缺陷)123456789#define MAX(a,b) a&amp;gt;b?a:bint main()&amp;#123;    int n1=1,n2=0;    int n3 = MAX(n1 , n2); &#x2F;&#x2F; n3 = 1    &#x2F;&#x2F; 在有参宏中使用自增运算符的时候, 就导致了    &#x2F;&#x2F; 逻辑上的错误. 且无法避免    int n4 = MA">
<meta property="og:type" content="article">
<meta property="og:title" content="20191007">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;30&#x2F;yuque&#x2F;ae95ug&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC]  基础知识复习 宏  无参宏 有参宏 (带有缺陷)123456789#define MAX(a,b) a&amp;gt;b?a:bint main()&amp;#123;    int n1=1,n2=0;    int n3 = MAX(n1 , n2); &#x2F;&#x2F; n3 = 1    &#x2F;&#x2F; 在有参宏中使用自增运算符的时候, 就导致了    &#x2F;&#x2F; 逻辑上的错误. 且无法避免    int n4 = MA">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-07T14:34:01.584Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/30/yuque/ae95ug/"/>





  <title>20191007 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/yuque/ae95ug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">20191007</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-30T05:34:55+08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<p><a name="69425377"></a></p>
<h1 id="基础知识复习"><a href="#基础知识复习" class="headerlink" title="基础知识复习"></a>基础知识复习</h1><ol>
<li><p>宏</p>
<ol>
<li>无参宏</li>
<li>有参宏 (带有缺陷)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) a&gt;b?a:b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">1</span>,n2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n3 = MAX(n1 , n2); <span class="comment">// n3 = 1</span></span><br><span class="line">    <span class="comment">// 在有参宏中使用自增运算符的时候, 就导致了</span></span><br><span class="line">    <span class="comment">// 逻辑上的错误. 且无法避免</span></span><br><span class="line">    <span class="keyword">int</span> n4 = MAX(n1++,n2++);<span class="comment">// n4 = 2,n1=3, n2=1    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><code>inline</code> 内联函数<br><br>语法: 在函数名前加上<code>inline</code>关键字, 这个函数就有可能成为内联函数.<br><br>成为内联函数的标准:</p>
<ol>
<li>函数题必须足够小(代码行数少)</li>
<li>函数内部不能有复杂的逻辑(switch,函数递归,各种嵌套的循环或选择结构都是不行的)</li>
<li>用法和函数一样</li>
<li>功能和有参宏差不多(直接将函数调用替换为函数体的代码.)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">1</span>,n2=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 正常方式调用函数</span></span><br><span class="line">    <span class="comment">// 但是在编译之后, 这里的函数调用会替换成函数体</span></span><br><span class="line">    <span class="comment">// 就类似于有参宏在预编译之后会被直接替换一样.</span></span><br><span class="line">    <span class="comment">// 但是如果实参是表达式的时候,会先计算出表达式的</span></span><br><span class="line">    <span class="comment">// 结果, 然后再进行替换(而有参宏是直接拿表达式来</span></span><br><span class="line">    <span class="comment">// 替换)</span></span><br><span class="line">    <span class="keyword">int</span> n3 = <span class="built_in">max</span>(n1++,n2++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><code>const</code><br><br><code>const</code>是一个常量修饰符, 在C++中常量的一些使用规则:</p>
<ol>
<li><p>常量必须被初始化</p>
</li>
<li><p>在使用常量的时候, 编译器会直接将常量名用它的初始值来替换(和无参宏一样. 在源码中使用宏的名字,经过预处理之后会被替换成宏的内容)</p>
</li>
<li><p>使用场合</p>
<ol>
<li><p>修饰指针</p>
</li>
<li><p>常量指针 : 将指针指向的内容修饰为常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> szBuff[<span class="number">100</span>]=&#123;<span class="string">"hello"</span>&#125;;</span><br><span class="line">szBuff[<span class="number">0</span>] = <span class="string">'A'</span>; <span class="comment">// 可以修改</span></span><br><span class="line"><span class="comment">// p就是常量指针</span></span><br><span class="line"><span class="comment">// 1. 指向的内容被修饰为常量,因此,不能通过p去修改内存.</span></span><br><span class="line"><span class="comment">// 2. p自身是可以被修改的</span></span><br><span class="line"><span class="comment">// 3. const只是在语法层面上限制一个指针不能修改它指向的内容, 至于指针指向的内容能不能被修改是不受const的改变.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p ; <span class="comment">// 可以不用初始化</span></span><br><span class="line">p = szBuff; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p1 = <span class="string">"hahahah"</span>;</span><br><span class="line">szBuff[<span class="number">0</span>] = <span class="string">'B'</span>; <span class="comment">// 仍然可以被修改</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="string">'A'</span> ; <span class="comment">// 语法报错. </span></span><br><span class="line">p1[<span class="number">0</span>] = <span class="string">'A'</span>; <span class="comment">// 语法报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针常量: 将指针自身修饰为常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> szBuff[<span class="number">100</span>]=&#123;<span class="string">"hello"</span>&#125;;</span><br><span class="line"><span class="comment">// 定义一个指针常量p, 指针常量必须被初始化.</span></span><br><span class="line"><span class="keyword">char</span>* p <span class="keyword">const</span>  = szBuff;</span><br><span class="line"><span class="comment">// 1. 指针不能再指向其它内存</span></span><br><span class="line">p = <span class="string">"hello"</span> ; <span class="comment">// 错误, p只能指向szBuff</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="string">'A'</span>; <span class="comment">//在语法上是通过.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p2 <span class="keyword">const</span> = <span class="string">"hahah"</span>;</span><br><span class="line">p2[<span class="number">0</span>] = <span class="string">'A'</span>; <span class="comment">// 在语法上是通过.在运行时就错误.因为p2保存的是一个常量字符串的地址, 常量字符串不能修改.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义指针时 ,<code>*</code>在 <code>const</code>的左边, 指针是一个指针常量</p>
</li>
<li><p>定义指针时 ,<code>*</code>在 <code>const</code>的右边, 指针是一个常量指针</p>
</li>
<li><p>修饰引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 定义一个引用.</span></span><br><span class="line"><span class="keyword">int</span>&amp; rNum = n;</span><br><span class="line">rNum = <span class="number">10</span>; <span class="comment">// 实际就是在修改变量n</span></span><br><span class="line"><span class="comment">// 常量引用. </span></span><br><span class="line"><span class="comment">// 不能rNum2去修改了.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rNum2 = n;</span><br><span class="line">rNum2 = <span class="number">20</span>; <span class="comment">// 报语法错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰成员函数<br><br>实际修饰的是<code>this</code>指针,也就是将<code>this</code>指针修饰成常量指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_nNum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// m_nNum = 100;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> MyClass* pObj)</span></span>&#123;</span><br><span class="line">    pObj-&gt;fun(); <span class="comment">// 报语法错误.</span></span><br><span class="line">    <span class="comment">// 原因分析:</span></span><br><span class="line">    <span class="comment">// 1. pObj是一个常量指针</span></span><br><span class="line">    <span class="comment">// 2. 成员函数有条件修改自身的成员变量, 这样相当于通过指针调用了成员函数, 成员函数在内部修改了成员, 实际就相当于间接通过指针修改了指针指向的内存. 这是常量指针所不允许的.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><br>修改版;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m_nNum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// const 修饰的是this指针.</span></span><br><span class="line">    <span class="comment">// this 就相当于 const MyClass* this;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_nNum = <span class="number">100</span>; <span class="comment">// 此处会报语法错误.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> MyClass* pObj)</span></span>&#123;</span><br><span class="line">    pObj-&gt;fun(); <span class="comment">// 不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><br>总结:</p>
</li>
<li><p>在成员函数后加上<code>const</code> , 成员函数就是一个常量成员函数, 在这样的函数内部不能修改自身的成员变量, 也不能调用其它的非常量成员函数</p>
</li>
<li><p>通过常量对象指针(<code>const MyClass* pObj</code>), 只能调用常量成员函数.</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>引用<br><br>性质:</p>
<ol>
<li><p>引用类型的变量不占用内存空间. 其内存空间来自被引用的变量.</p>
<ol>
<li>定义的时候必须初始化</li>
<li>不能再引用其它的变量</li>
<li>修改自身的时候, 被引用的变量也会被修改,被引用的变量被修改了, 引用类型的变量也会被修改, 因为它们使用是同一块内存空间.</li>
</ol>
</li>
<li><p>使用场合</p>
<ol>
<li><p>传参</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; l, inr&amp; r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = l;</span><br><span class="line">    l=r;</span><br><span class="line">    r =t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">10</span>,n2=<span class="number">20</span>;</span><br><span class="line">    swap(n1,n2); <span class="comment">// 执行之后, n1=20,n2=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递函数返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nNum = <span class="number">100</span>;</span><br><span class="line">    fun(nNum) = <span class="number">200</span>; <span class="comment">// 1. 修改了哪块内存?(nNum)</span></span><br><span class="line">    <span class="keyword">int</span> n2 = fun(nNum);</span><br><span class="line">    n2 = <span class="number">10</span>; <span class="comment">// nNum有被修改吗? 没有. 因为n2不是引用类型的变量, 它拥有自己的内存空间. 所以修改了n2不会影响nNum</span></span><br><span class="line">    <span class="keyword">int</span>&amp; rNum = fun(nNum);</span><br><span class="line">    rNum = <span class="number">10</span>; <span class="comment">// 修改到nNum的内存空间了. 因为rNum是一个引用, 没有独立的内存空间,其内存空间使用的就是nNum的.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>类型转换</p>
<ol>
<li><p>const_cast：常量类型转换 • 去除常量类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pStr)</span></span>&#123;</span><br><span class="line">    pStr[<span class="number">0</span>] = <span class="string">'A'</span>; <span class="comment">//语法报错.</span></span><br><span class="line">    <span class="comment">// 1. C语言风格</span></span><br><span class="line">    <span class="keyword">char</span>* p = (<span class="keyword">char</span>*)pStr;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="string">'A'</span>; <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="comment">// 2. c++风格</span></span><br><span class="line">    <span class="keyword">char</span>* p2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pStr);<span class="comment">// 类似于(char*)pStr    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">100</span>];</span><br><span class="line">    fun(buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static_cast：静态类型转换 •编译器认可的，例如char转为int</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会将3.14从double类型隐式转换成int类型再传参</span></span><br><span class="line">	fun( <span class="number">3.14</span> ) ; <span class="comment">// 语法能通过,但是会报一个警告:精度丢失....    	// 1. C语言风格</span></span><br><span class="line">    fun( (<span class="keyword">int</span>) <span class="number">3.14</span> );<span class="comment">// 强制转换成和实参一样的类型</span></span><br><span class="line">    <span class="comment">// 2. c++</span></span><br><span class="line">    fun( <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3.14</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>reinterpret_cast：强制类型转换 •编译器不认可的，例如int*转为int<br><br>用于编译器无法进行隐式转换时的类型转换.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="number">0x403000</span>; <span class="comment">// 语法报错.类型不匹配</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// C语言风格</span></span><br><span class="line">    p = (<span class="keyword">int</span>*)<span class="number">0x403000</span>;</span><br><span class="line">    <span class="comment">//c++</span></span><br><span class="line">    p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="number">0x403000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dynamic_cast：动态类型转换,用于将父类和子类的指针或引用进行转换的(继承的时候会用到，能够将基类转换为派生类)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">int</span> nNum[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">int</span> m_nNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> B;</span><br><span class="line">    MyClass* pObj = obj; <span class="comment">// 语法报错.</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 可以在语法上通过.</span></span><br><span class="line">    <span class="comment">// 但在运行的时候会出现严重问题. 因为obj</span></span><br><span class="line">    <span class="comment">// 本质上并非是MyClass类型,而是B类型.</span></span><br><span class="line">    pObj = (MyClass*) obj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dynamic_cast可以检测是否能够转换</span></span><br><span class="line">    <span class="comment">// 如果不能就返回nullptr</span></span><br><span class="line">    pObj = <span class="keyword">dynamic_cast</span>&lt;MyClass*&gt;(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p><a name="a2e6ee0b"></a></p>
<h1 id="面向对象-类"><a href="#面向对象-类" class="headerlink" title="面向对象-类"></a>面向对象-类</h1><p>类的组成:</p>
<ol>
<li><p>成员变量</p>
<ol>
<li><p>一个对象的数据组成. 一个对象的内存空间就是由成员变量组成.</p>
</li>
<li><p>成员在类中的声明顺序决定了成员变量在内存中的顺序.</p>
</li>
<li><p>使用成员变量</p>
<ol>
<li><p>都需要提供一个对象, 才能使用成员变量.</p>
</li>
<li><p>在成员函数内部, this指针来表示当前对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this也可以不写, </span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_nNum1 = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 不写的时候编译器会自动加上.</span></span><br><span class="line">        m_nNum2 = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的外部, 只能通过对象变量来访问成员变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass obj;</span><br><span class="line">    <span class="comment">// 必须通过对象来使用成员变量</span></span><br><span class="line">	obj.m_nNum2 = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>成员函数</p>
<ol>
<li><p>成员函数内部会自带一个<code>this</code>指针. 这个指针从哪来的?</p>
<ol>
<li>通过对象调用函数的时候c++会自动将对象的内存首地址赋值给成员函数内部的this指针.这样一来, 成员函数被调用之后this指针就保存着调用了这个成员函数的对象变量.</li>
</ol>
</li>
<li><p>普通成员函数</p>
<ol>
<li>需要通过对象才能调用.</li>
<li>通过this指针也能调用.</li>
<li>其它情况和普通函数一样. 也可以设置默认参数, 也可以进行函数重载.</li>
</ol>
</li>
<li><p>构造函数</p>
<ol>
<li><p>构造函数是一个特殊的成员函数. 它的作用是用于构造一个对象. 它没有返回值, 因为返回值默认就是一个类对象.</p>
</li>
<li><p>构造函数只能被自动调用.</p>
</li>
<li><p>定义变量时(定义局部变量, 全局变量)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyClass g_obj ; <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1; <span class="comment">// 调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从堆空间申请对象时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass* pObj = <span class="keyword">new</span> MyClass;<span class="comment">//调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数形参</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(MyClass obj)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass obj1; <span class="comment">// 调用了构造函数</span></span><br><span class="line">    fun( obj1 );<span class="comment">// 会为形参obj调用构造函数.</span></span><br><span class="line">    fun( obj1 );<span class="comment">// 会为形参obj调用构造函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    MyClass obj2 ;</span><br><span class="line">    MyClass obj3 = obj2 ;</span><br><span class="line">    MyClass obj1 = fun(); <span class="comment">// 给obj1调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数可以进行重载</p>
</li>
<li><p>当构造函数没有进行重载的时候,只能调用无参的构造函数. 无参构造函数是C++编译器默认提供的一个构造函数(不需要定义就有了), 但如果定义了其它版本的构造函数, 编译器就不再提供无参构造.</p>
</li>
<li><p>再进行构造函数重载之后, 构造对象的时候, 就可以通过传参来决定调用哪个重载版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*重载了构造函数*/</span></span><br><span class="line">	MyClass()&#123;&#125;</span><br><span class="line">    MyClass(<span class="keyword">int</span> n)&#123;&#125;</span><br><span class="line">    MyClass(<span class="keyword">double</span> d)&#123;&#125;</span><br><span class="line">    MyClass(<span class="keyword">int</span> n , <span class="keyword">double</span> d)&#123;&#125;</span><br><span class="line">    MyClass(MyClass&amp; obj )&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(MyClass obj)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClsas <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 会为obj11调用转换构造函数.</span></span><br><span class="line">    <span class="comment">//  MyClss obj11(2);</span></span><br><span class="line">    MyClss obj11 = fun2();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐式转换:</span></span><br><span class="line">    <span class="comment">// C++编译器会尝试将整型的实参5,转换成MyClass类型的形参. 但C++编译器是不能没有任何依据地转换.规则: 形参是类类型,并且具有一个构造函数刚好可以将实参传递进去. 此时编译器就可以将实参传给形参的构造函数,直接构造出形参, 而不是直接将实参赋值给形参.</span></span><br><span class="line">     fun( <span class="number">5</span> ); <span class="comment">// 不会报错, 且会给形参obj调用构造函数: MyClass(int n)&#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在构造对象时, 会根据实参来调用不同版本的构造函数.</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">5</span>)</span></span>;<span class="comment">// MyClass(int n)&#123;&#125;</span></span><br><span class="line">    fun( obj1 );<span class="comment">// 给形参obj调用了构造函数, 选择的版本:MyClass(MyClass&amp; obj )&#123;&#125;</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    MyClass *p = <span class="keyword">new</span> MyClass(<span class="number">5</span>,<span class="number">1</span>);<span class="comment">// MyClass(int n , double d)&#123;&#125;</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>;<span class="comment">// MyClass(MyClass&amp; obj )&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数的一些术语:</p>
<ol>
<li>默认构造 : 指的是没有形参的构造函数, 由编译器默认提供, 在某些场合编译器需要自动调用一个类对象的构造函数时, 只能调用默认构造.例如: 子类继承了父类,当子类对象被构造的时候, 父类的构造也会被自动调用,此时就只能自动调用父类的默认构造</li>
<li>转换构造 : 指的是那些只有一个形参,且参数类型是非本类类型的构造函数们.  一般能够显式调用(例如 <code>MyClass obj(5)</code>), 也能隐式调用: <code>fun(5);</code> fun的形参是<code>MyClass</code>类型</li>
<li>拷贝构造: 指的是只有一个形参, 且参数类型是本类类型的引用.  一般是在定义一个对象的时候, 将另一个对象作为初始值时,就会自动调用这个版本的构造函数, 一般编译器会默认提供一个拷贝构造, 默认提供的拷贝构造会将对象的内存空间进行拷贝.<br><br>类中包含有指针成员的时候, 一般就需要自己编写拷贝构造, 实现对指针指向的内存进行拷贝的功能. 否则默认拷贝构造是不会去拷贝指针指向的内容. (深拷贝和浅拷贝的区别)</li>
<li>带参构造 : 含有两个以上的形参的构造函数统称带参构造.</li>
</ol>
</li>
</ol>
</li>
<li><p>析构函数</p>
<ol>
<li>作用和构造函数相反, 当一个对象被销毁的时候,就会调用析构函数.</li>
</ol>
</li>
<li><p>运算符重载函数</p>
</li>
</ol>
</li>
<li><p>访问控制</p>
<ol>
<li>public : 类内类外都能访问.</li>
<li>protected : 控制在子类内部能访问, 在类外不能访问.</li>
<li>private : 在子类和类外都不能访问.</li>
</ol>
</li>
<li><p>静态成员</p>
</li>
<li><p>友元</p>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/30/yuque/yxv7iu/" rel="next" title="20190928">
                <i class="fa fa-chevron-left"></i> 20190928
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/30/yuque/ewx5pu/" rel="prev" title="20191008">
                20191008 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识复习"><span class="nav-number">1.</span> <span class="nav-text">基础知识复习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象-类"><span class="nav-number">2.</span> <span class="nav-text">面向对象-类</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
